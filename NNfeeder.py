"""Module for outsourcing the preprocessing of raw data to prepare for neural network.
Rescale to 81 nm/px, background subtraction and contrast enhancement.

Returns:
    [type]: [description]
"""


import numpy as np
from skimage import exposure, filters, transform

from eda_original.SmartMicro.ImageTiles import getTilePositionsV2


def prepareNNImages(bact_img, ftsz_img, model, bacteria=False):
    """Preprocess raw iSIM images before running them throught the neural network.

    Args:
        bact_img ([type]): full frame of the mito data as numpy array
        ftsz_img ([type]): full frame of the drp data as numpy array
        nnImageSize ([type]): image size that is needed for the neural network. Default is 128

    Returns:
        [type]: Returns a 3D numpy array that contains the data for the neural network and the
        positions dict generated by getTilePositions for tiling.
    """
    # Set iSIM specific values
    pixelCalib = 56  # nm per pixel
    sig = 121.5/81  # in pixel
    resizeParam = pixelCalib/81  # no unit
    try:
        nnImageSize = model.layers[0].input_shape[0][1]
    except AttributeError:
        nnImageSize = model
    positions = None

    # Preprocess the images
    if nnImageSize is None or ftsz_img.shape[1] > nnImageSize:
        # Adjust to 81nm/px
        bact_img = transform.rescale(bact_img, resizeParam)
        ftsz_img = transform.rescale(ftsz_img, resizeParam)
        # This leaves an image that is smaller then initially

        # gaussian and background subtraction
        bact_img = filters.gaussian(bact_img, sig, preserve_range=True)
        ftsz_img = (filters.gaussian(ftsz_img, sig, preserve_range=True)
                   - filters.gaussian(ftsz_img, sig*5, preserve_range=True))

        # Tiling
        if nnImageSize is not None:
            positions = getTilePositionsV2(ftsz_img, nnImageSize)
            contrastMax = 255
        else:
            contrastMax = 1

        # Contrast
        ftsz_img = exposure.rescale_intensity(
            ftsz_img, (np.min(ftsz_img), np.max(ftsz_img)), out_range=(0, contrastMax))
        bact_img = exposure.rescale_intensity(
            bact_img, (np.mean(bact_img), np.max(bact_img)),
            out_range=(0, contrastMax))

    else:
        positions = {'px': [(0, 0, ftsz_img.shape[1], ftsz_img.shape[1])],
                     'n': 1, 'overlap': 0, 'stitch': 0}

    # Put into format for the network
    if nnImageSize is not None:
        ftsz_img = ftsz_img.reshape(1, ftsz_img.shape[0], ftsz_img.shape[0], 1)
        bact_img = bact_img.reshape(1, bact_img.shape[0], bact_img.shape[0], 1)
        inputDataFull = np.concatenate((bact_img, ftsz_img), axis=3)

        # Cycle through these tiles and make one array for everything
        i = 0
        inputData = np.zeros((positions['n']**2, nnImageSize, nnImageSize, 2), dtype=np.uint8())
        for position in positions['px']:

            inputData[i, :, :, :] = inputDataFull[:,
                                                  position[0]:position[2],
                                                  position[1]:position[3],
                                                  :]
            if bacteria:
                inputData[i, :, :, 1] = exposure.rescale_intensity(
                    inputData[i, :, :, 1], (0, np.max(inputData[i, :, :, 1])),
                    out_range=(0, 255))

            inputData[i, :, :, 0] = exposure.rescale_intensity(
                inputData[i, :, :, 0], (0, np.max(inputData[i, :, :, 0])),
                out_range=(0, 255))
            i = i+1
        inputData = inputData.astype('uint8')
    else:
        # This is now missing the tile-wise rescale_intensity for the mito channel.
        # Image shape has to be in multiples of 4, not even quadratic
        cropPixels = (bact_img.shape[0] - bact_img.shape[0] % 4,
                      bact_img.shape[1] - bact_img.shape[1] % 4)
        bact_img = bact_img[0:cropPixels[0], 0:cropPixels[1]]
        ftsz_img = ftsz_img[0:cropPixels[0], 0:cropPixels[1]]

        positions = getTilePositionsV2(bact_img, 128)
        bact_img = bact_img.reshape(1, bact_img.shape[0], bact_img.shape[0], 1)
        ftsz_img = ftsz_img.reshape(1, ftsz_img.shape[0], ftsz_img.shape[0], 1)
        inputData = np.stack((bact_img, ftsz_img), 3)

    return inputData, positions
